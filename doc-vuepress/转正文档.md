## 自我介绍

大家好，我...

果锅（Guoguo）的由来

=

- [Vue3 组件库 Element ProMax](https://shixindea.github.io/element-promax-docs/en-US/)
- [JavaScript 工具类 Guoguo-utils](https://shixindea.github.io/shixinde-apifox-swagger/)
- [vuepress 快速模板 Guoguo-vuepress](https://www.npmjs.com/package/@shixinde/vuepress-theme-init)
- [个人笔记 guoguo-notes](https://www.npmjs.com/package/@shixinde/vuepress-theme-init)
- [Git 提交规范 Guoguo-cz](https://www.npmjs.com/package/@shixinde/guoguo-cz)
- [Apifox Swagger文档生成与TS类型解析工具 @shixinde/apifox-swagger](https://www.npmjs.com/package/@shixinde/apifox-swagger)
- [其他npm包 @shixinde](https://www.npmjs.com/settings/shixinde/packages)




## 框架 vs 架构

> 1. 框架是什么：主要分为`约束性框架`和 `集成类框架`
>
>    **约束性框架：（Vue、React）-- 从底层构建的“约束型框架**
>
>    1. 你的代码被框架调用，而不是你去调用框架
>
>    2. **约定优于配置**：框架通常有明确的目录结构、命名规范和开发模式
>
>    **集成类框架：（若依、芋道） -- 技术堆积的一个半成品框架**
>
>    1. 它提供了一套骨架和约定，让你在这个骨架之上填充具体的业务逻辑来构建应用。
>    2. 特点主要体现在快速开发
>
>
> 2. 架构是什么：系统的宏观结构设计，它定义了系统由哪些**部分**组成，这些部分之间如何**交互**，以及指导设计和演进的**原则与约束**。主要关心的是如何构建一个**可维护、可扩展、可测试**的复杂系统



最简单的例子 Spring Boot 与 Spring Cloud

综上所述，我们平时使用的Vue、React都属于约束型框架，主要表现是用户使用这个框架真正可以做到约定大于配置，反而集成类框架是将各种技术堆积的结果，一般在项目中我们大多数使用的都是以约束性框架为核心的集成类框架。

个人理解，初级程序员考虑某一个小业务，主要体现在 `src和自己的小文件夹`【代码逻辑没有bug为佳】

中级程序员可以有意识的考虑整个项目，比如全局代码格式化规范、代码提交规范、项目提交流程、全局loading、hooks、utils等核心业务封装，主要体现在 `包裹src的整个项目文件夹`【保证团队其他成员代码写着顺手和有一定的抗极端场景为佳】

高级程序员考虑的是各个项目间的核心技术的通用性就属于架构层次，主要体现在公司内部组件库、工具类、统一规范、统一各个项目的技术架构等，主要有两种形式 `pnpm-workspace-monorepo` 或者 `上传npm包，使用package.json`保持各个项目中的通用性。【保证新同学接触到各个框架、在各个项目中交互起来非常通畅为佳】



## 公司项目架构、框架

> 架构使用 `pnpm-workspace-monorepo`

> 1. Apifox生成Swagger
> 2. 根据Apifox生成的Swagger二次封装react-query请求
>
>    1. 后端数据进入前端代码后统一被封装
>
>       **对前后端约束的影响**
>       
>       待完善 null undefined string|number|enum 类型
>
> 3. 工具类utils
>
>    1. crypto - 加密解密
>
> 4. 搭建桥梁 
>
>    1. H5被嵌套到小程序中时，调用小程序中的方法
>       1. 通过H5，内嵌到小程序中，调用小程序的拍照和拨打电话等。
>
>    2. H5生成APP后 
>       1. 打印( 1:蓝牙打印 | 2:Wi-Fi 打印)
>       2. 获取 app 用户信息、header信息（ third-appid、third-token、third-version）
>       3. 判断当前是否是APP环境等
>







## 上家公司项目框架、约束、规范

https://shixindea.github.io/guoguo-notes/%E8%A2%81%E6%9E%9C%E9%94%85%E7%94%9F%E6%80%81/%E9%A1%B9%E7%9B%AE%E6%A1%86%E6%9E%B6%E5%8F%8A%E6%9E%B6%E6%9E%84/%E9%87%8D%E8%A6%81_%E6%A1%86%E6%9E%B6%20-%20%E5%88%9D%E5%A7%8B%E5%8C%96%E9%A1%B9%E7%9B%AE%E7%BA%A6%E6%9D%9F.html



## 可优化事项

小程序每次进入新页面，会清理 third-token、third-account等问题



## 项目建议

统一项目代码格式化，很重要！！！ 

小程序打包区分路径，dev文件夹，build文件夹 等

全局loading问题





## 未来待完成

1. 根据公司技术栈封装初试框架   `袁果锅生态===>项目框架及架构===>新项目框架前后端约定`





## 问题

不清楚公司未来发展路线，以及个人主要所在的项目，不能统一解决部分问题





## 已修改同步消息

#### 1. 小程序请求接口默认不抛出异常    -- 响应拦截器 异常状态码封装

**场景：**

```tsx
const payKey = await omoGetPayKeyByOmoCourseOrderId(
  router.params.omoCourseOrderId || ''
)
console.log('payKey ===>', payKey)
const res = await postAcceptTransferOrder({
  transferKey: payKey || ''
})
```

**目前：**

所有报错前端没有统一拦截，每次请求接口都要判断状态码 code

**理论状态：**

code=1 表示成功，所有提示走前端 

code=401 表示token过期或者未登录，前端监听出来弹框 

code为其他 表示失败，所有提示走后端

```diff
export function omoGetPayKeyByOmoCourseOrderId(omoCourseOrderId) {
  setShowApiErrorToast(true)
  return request(
    `/omo/course/order/message/${omoCourseOrderId}`,
    {},
    {
      method: 'GET',
+      throwingAnException: true   // 异常抛出
    }
  )
}
```



